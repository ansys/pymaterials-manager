# Copyright (C) 2022 - 2025 ANSYS, Inc. and/or its affiliates.
# SPDX-License-Identifier: MIT
#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""Provides the ``mapdl_reader`` module."""

from collections import defaultdict
import inspect

from pydantic import BaseModel

from ansys.materials.manager._models._common import _MapdlCore
from ansys.materials.manager._models._common.interpolation_options import InterpolationOptions
import ansys.materials.manager._models._material_models as PydanticModels
from ansys.materials.manager._models.material import Material

# Discover all Pydantic models in the module dynamically
# could be fixed and integrated with the one below
MODEL_REGISTRY = {
    name: cls
    for name, cls in inspect.getmembers(PydanticModels, inspect.isclass)
    if issubclass(cls, BaseModel) and cls is not BaseModel
}

# this could be autogenerated dynamically
MP_MATERIAL_MODELS = {
    "Density": {"DENS": "density"},
    "ElasticityOrthotropic": {
        "EX": "youngs_modulus_x",
        "EY": "youngs_modulus_y",
        "EZ": "youngs_modulus_z",
        "GXY": "shear_modulus_xy",
        "GYZ": "shear_modulus_yz",
        "GXZ": "shear_modulus_xz",
        "PRXY": "poissons_ratio_xy",
        "PRYZ": "poissons_ratio_yz",
        "PRXZ": "poissons_ratio_xz",
    },
    "ElasticityIsotropic": {"EX": "youngs_modulus", "PRXY": "poissons_ratio"},
    "CoefficientofThermalExpansionIsotropic::Secant": {"ALPX": "coefficient_of_thermal_expansion"},
    "CoefficientofThermalExpansionOrthotropic::Secant": {
        "ALPX": "coefficient_of_thermal_expansion_x",
        "ALPY": "coefficient_of_thermal_expansion_y",
        "ALPZ": "coefficient_of_thermal_expansion_z",
    },
    "CoefficientofThermalExpansionIsotropic::Instantaneus": {
        "CTEX": "coefficient_of_thermal_expansion"
    },
    "CoefficientofThermalExpansionOrthotropic::Instantaneus": {
        "CTEX": "coefficient_of_thermal_expansion_x",
        "CTEY": "coefficient_of_thermal_expansion_y",
        "CTEZ": "coefficient_of_thermal_expansion_z",
    },
    "ThermalConductivityIsotropic": {"KXX": "thermal_conductivity"},
    "ThermalConductivityOrthotropic": {
        "KXX": "thermal_conductivity_x",
        "KYY": "thermal_conductivity_y",
        "KZZ": "thermal_conductivity_z",
    },
}


TB_MATERIAL_MODELS = {
    "HillYieldCriterion::Separated Hill Potentials for Plasticity and Creep::No": {
        "rxx": "yield_stress_ratio_x",
        "ryy": "yield_stress_ratio_y",
        "rzz": "yield_stress_ratio_z",
        "rxy": "yield_stress_ratio_xy",
        "ryz": "yield_stress_ratio_yz",
        "rxz": "yield_stress_ratio_xz",
    },
    "HillYieldCriterion::Separated Hill Potentials for Plasticity and Creep::Yes": {},
    "ElasticityOrthotropic": {
        "c1": "youngs_modulus_x",
        "c2": "youngs_modulus_y",
        "c3": "youngs_modulus_z",
        "c4": "shear_modulus_xy",
        "c5": "shear_modulus_yz",
        "c6": "shear_modulus_xz",
        "c7": "poissons_ratio_xy",
        "c8": "poissons_ratio_yz",
        "c9": "poissons_ratio_xz",
    },
    "ElasticityAnisotropic": {
        "c1": "c1",
        "c2": "c2",
        "c3": "c3",
        "c4": "c4",
        "c5": "c5",
        "c6": "c6",
        "c7": "c7",
        "c8": "c8",
        "c9": "c9",
        "c10": "c10",
        "c11": "c11",
        "c12": "c12",
        "c13": "c13",
        "c14": "c14",
        "c15": "c15",
        "c16": "16",
        "c17": "c17",
        "c18": "c18",
        "c19": "c19",
        "c20": "c20",
        "c21": "c21",
    },
    "IsotropicHardening": {"Stress": "stress"},
}


def _parse_mp_list(mapdl: _MapdlCore):
    return "\n".join(s for s in mapdl.mplist().splitlines() if s.strip())


def _parse_mp_temp_table(raw_data: str) -> tuple[dict, list[str]]:
    lines = [line.strip() for line in raw_data.strip().split("\n") if line.strip()]
    result = {}
    ids = []
    current_section = None
    for line in lines:
        if line.startswith("MATERIAL NUMBER"):
            material_number = f"MATERIAL NUMBER {int(line.split()[-1])}"
            ids.append(line.split()[-1])
            result[material_number] = {}
        # Detect section headers
        elif line.startswith("TEMP"):
            current_section = line.split()[1]
            result[material_number][current_section] = []
        # Parse value-only rows
        elif current_section:
            parts = line.split()
            if len(parts) == 1:
                value = float(parts[0])
                result[material_number][current_section].append({"value": value})
            else:
                temp = float(parts[0])
                value = float(parts[1])
                result[material_number][current_section].append(
                    {"Temperature": temp, "value": value}
                )
    return result, ids


def _extract_defined_models_for_material(material_model_dict: dict):
    defined_models = {}
    for model_name, model_properties in MP_MATERIAL_MODELS.items():
        if all(key in material_model_dict.keys() for key in model_properties.keys()):
            defined_properties = {}
            temperature_parameter = []
            for model_property in model_properties:
                single_property_values = material_model_dict[model_property]
                if len(single_property_values) > 1:
                    temperature_parameter_value = []
                    parameter_value = []
                    for property_value in single_property_values:
                        temperature_parameter_value.append(property_value["Temperature"])
                        parameter_value.append(property_value["value"])
                    temperature_parameter.append({"Temperature": temperature_parameter_value})
                    defined_properties[model_properties[model_property]] = {
                        "value": parameter_value,
                        "units": "",
                    }
                else:
                    defined_properties[model_properties[model_property]] = {
                        "value": [material_model_dict[model_property][0]["value"]],
                        "units": "",
                    }
            defined_models[model_name] = defined_properties
            if len(temperature_parameter) > 0:
                if len(temperature_parameter) > 1:
                    for i in range(len(temperature_parameter) - 1):
                        if not temperature_parameter[i] == temperature_parameter[i + 1]:
                            raise Exception("Multiple temperatures defined for same properties.")
                    temperature_parameter = [temperature_parameter[0]]
                defined_properties["independent_parameters"] = [
                    {
                        "name": "Temperature",
                        "values": {"value": temperature_parameter[0]["Temperature"], "units": ""},
                    }
                ]

            defined_models[model_name] = defined_properties

    # restrict to othotropic
    if "ElasticityOrthotropic" in defined_models.keys():
        defined_models.pop("ElasticityIsotropic", None)
    if "ThermalConductivityOrthotropic" in defined_models.keys():
        defined_models.pop("ThermalConductivityIsotropic")
    if "CoefficientofThermalExpansionOrthotropic::Instantaneus" in defined_models.keys():
        defined_models.pop("CoefficientofThermalExpansionIsotropic::Instantaneus", None)
    if "CoefficientofThermalExpansionOrthotropic::Secant" in defined_models.keys():
        defined_models.pop("CoefficientofThermalExpansionIsotropic::Secant", None)
    return defined_models


def _try_parse_tb_model_class_name(intro_text: str) -> str | None:
    intro_text = intro_text.lower()
    class_name = None
    if "hill pl" in intro_text:
        class_name = "HillYieldCriterion::Separated Hill Potentials for Plasticity and Creep::No"
    elif "hill" in intro_text and not "hill pl" in intro_text:
        class_name = "HillYieldCriterion::Separated Hill Potentials for Plasticity and Creep::Yes"
    elif "orthotropic with major poissons ratio" in intro_text:
        class_name = "ElasticityOrthotropic"
    elif "anisotropic elastic stiffness form" in intro_text:
        class_name = "ElasticityAnisotropic"
    elif "isotropic hardening plasticity" in intro_text:
        class_name = "IsotropicHardening"
    else:
        print("class not found!")
    return class_name


def _try_parse_value(s: str) -> float | int | bool | None:
    s_clean = s.strip().lower()
    if s_clean in ["true", "on"]:
        return True
    elif s_clean in ["false", "off"]:
        return False
    try:
        return float(s) if "." in s else int(s)
    except ValueError:
        return None


def _split_description_table_data(raw_text: str) -> tuple[str, str]:
    lines = raw_text.strip().split("\n")
    table_start_index = next(
        i
        for i, line in enumerate(lines)
        if line.strip().startswith("1")
        and all(part.strip().isdigit() for part in line.strip().split())
    )
    intro_text = "\n".join(lines[:table_start_index])
    table_str = "\n".join(lines[table_start_index:])
    return intro_text, table_str


def _parse_tb_table(table_str: str) -> dict:
    lines = [line.strip() for line in table_str.strip().split("\n") if line.strip()]
    data = defaultdict(list)
    skip_lines = ["list", "*****mapdl", "do", "field"]

    for line in lines:
        parts = line.split()
        if all(part.replace(".", "", 1).isdigit() for part in parts):  # skip header row
            continue
        if len(parts) > 2:
            if parts[0] == "C" and type(_try_parse_value(parts[1])) == int:
                parts = [parts[0] + parts[1]] + parts[2:]
        key = parts[0]
        if (
            key.lower() in skip_lines
            or key.lower() == "quantization"
            or key.lower() == "extrapolation"
        ):
            continue
        elif key.lower() == "interpolation":
            key = "algorithm_type"
            values = [" ".join(parts[3:])]
        else:
            if key.lower() == "temps":
                key = "Temperature"
            elif key.lower() == "interpolation":
                key = "algorithm_type"
                values = [" ".join(parts[3:])]
            elif key.lower() == "caching":
                key = "cached"
            elif key.lower() == "normalization":
                key = "normalized"
            values = [_try_parse_value(p) for p in parts[1:]]
            values = [v for v in values if v is not None]
        data[key].extend(values)
    return dict(data)


def _extract_tb_data(mapdl: _MapdlCore, id) -> str | None:
    try:
        tb_data = mapdl.tblist(mat=id)
        return tb_data
    except:
        return None


def _parse_tb_table_to_dict(class_name: str, table_str: str) -> dict:
    if class_name and class_name in TB_MATERIAL_MODELS.keys():
        tb_filtered = _parse_tb_table(table_str)
        material_model = TB_MATERIAL_MODELS[class_name]
        interpolation_fields = InterpolationOptions.model_fields
        remaining_fields = tb_filtered.copy()
        built_model = {}
        interpolation_options = {}
        independent_variables = []
        material_key = material_model.keys()
        for key, values in tb_filtered.items():
            if key.lower() in material_key:
                built_model[material_model[key.lower()]] = {"value": values, "units": ""}
                remaining_fields.pop(key)
            if key in interpolation_fields.keys():
                interpolation_options[key] = values[0]
                remaining_fields.pop(key)

        upper_dict = {}
        lower_dict = {}
        for key, value in remaining_fields.items():
            if key.isupper():
                upper_dict[key] = value
            elif key.islower():
                lower_dict[key] = value

        for key, value in upper_dict.items():
            variable = {}
            variable["name"] = key
            variable["values"] = {"value": value, "units": ""}
            if key.lower() in lower_dict.keys():
                variable["lower_limit"] = lower_dict[key.lower()][0]
                variable["upper_limit"] = lower_dict[key.lower()][1]
                variable["default_value"] = lower_dict[key.lower()][-1]
            independent_variables.append(variable)
        if len(independent_variables) > 0:
            built_model["independent_parameters"] = independent_variables
        if len(interpolation_options.keys()) > 0:
            built_model["interpolation_options"] = interpolation_options
    return {class_name.split("::")[0]: built_model}


def read_mapdl(mapdl: _MapdlCore) -> dict[str, Material]:
    """
    Read materials from a provided MAPDL session.

    Returns them indexed by the material ID.

    Parameters
    ----------
    mapdl : _MapdlCore
        Active pyMAPDL session.

    Returns
    -------
    dict[str, Material]
        Materials currently active in the MAPDL session, indexed by their material ID.
    """
    raw_data = _parse_mp_list(mapdl)
    material_prop_dict, ids = _parse_mp_temp_table(raw_data)
    materials = {}
    i = 0
    for material_name, material_properties in material_prop_dict.items():
        defined_models = _extract_defined_models_for_material(material_properties)
        table_models = _extract_tb_data(mapdl, ids[i])
        if table_models:
            intro_text, table_str = _split_description_table_data(table_models)
            class_name = _try_parse_tb_model_class_name(intro_text)
            table_model_defined = _parse_tb_table_to_dict(class_name, table_str)
            defined_models.update(table_model_defined)
        material = Material(name=material_name)
        for class_name, payload in defined_models.items():
            model_class = MODEL_REGISTRY.get(class_name)
            if model_class:
                instance = model_class(**payload)
                material.append_models([instance])
        materials[material_name] = material
        i += 1
    return materials
