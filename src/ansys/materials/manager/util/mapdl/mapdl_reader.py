# Copyright (C) 2022 - 2025 ANSYS, Inc. and/or its affiliates.
# SPDX-License-Identifier: MIT
#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""Provides the ``mapdl_reader`` module."""

import inspect

from pydantic import BaseModel

from ansys.materials.manager._models._common._base import _MapdlCore
import ansys.materials.manager._models._material_models as PydanticModels
from ansys.materials.manager._models.material import Material

# Discover all Pydantic models in the module dynamically
# could be fixed and integrated with the one below
MODEL_REGISTRY = {
    name: cls
    for name, cls in inspect.getmembers(PydanticModels, inspect.isclass)
    if issubclass(cls, BaseModel) and cls is not BaseModel
}

# this could be autogenerated dynamically
MATERIAL_MODELS = {
    "Density": {"DENS": "density"},
    "ElasticityOrthotropic": {
        "EX": "youngs_modulus_x",
        "EY": "youngs_modulus_y",
        "EZ": "youngs_modulus_z",
        "GXY": "shear_modulus_xy",
        "GYZ": "shear_modulus_yz",
        "GXZ": "shear_modulus_xz",
        "PRXY": "poissons_ratio_xy",
        "PRYZ": "poissons_ratio_yz",
        "PRXZ": "poissons_ratio_xz",
    },
    "ElasticityIsotropic": {"EX": "youngs_modulus", "PRXY": "poissons_ratio"},
    "CoefficientofThermalExpansionIsotropic::Secant": {"ALPX": "coefficient_of_thermal_expansion"},
    "CoefficientofThermalExpansionOrthotropic::Secant": {
        "ALPX": "coefficient_of_thermal_expansion_x",
        "ALPY": "coefficient_of_thermal_expansion_y",
        "ALPZ": "coefficient_of_thermal_expansion_z",
    },
    "CoefficientofThermalExpansionIsotropic::Instantaneus": {
        "CTEX": "coefficient_of_thermal_expansion"
    },
    "CoefficientofThermalExpansionOrthotropic::Instantaneus": {
        "CTEX": "coefficient_of_thermal_expansion_x",
        "CTEY": "coefficient_of_thermal_expansion_y",
        "CTEZ": "coefficient_of_thermal_expansion_z",
    },
    "ThermalConductivityIsotropic": {"KXX": "thermal_conductivity"},
    "ThermalConductivityOrthotropic": {
        "KXX": "thermal_conductivity_x",
        "KYY": "thermal_conductivity_y",
        "KZZ": "thermal_conductivity_z",
    },
}


def _parse_mp_list(mapdl: _MapdlCore):
    return "\n".join(s for s in mapdl.mplist().splitlines() if s.strip())


def _parse_mp_temp_table(raw_data: str) -> dict:
    lines = [line.strip() for line in raw_data.strip().split("\n") if line.strip()]
    result = {}
    current_section = None
    for line in lines:
        if line.startswith("MATERIAL NUMBER"):
            material_number = f"MATERIAL NUMBER {int(line.split()[-1])}"
            result[material_number] = {}
        # Detect section headers
        elif line.startswith("TEMP"):
            current_section = line.split()[1]
            result[material_number][current_section] = []
        # Parse value-only rows
        elif current_section:
            parts = line.split()
            if len(parts) == 1:
                value = float(parts[0])
                result[material_number][current_section].append({"value": value})
            else:
                temp = float(parts[0])
                value = float(parts[1])
                result[material_number][current_section].append(
                    {"Temperature": temp, "value": value}
                )
    return result


def _extract_defined_models_for_material(material_model_dict: dict):
    defined_models = {}
    for model_name, model_properties in MATERIAL_MODELS.items():
        if all(key in material_model_dict.keys() for key in model_properties.keys()):
            defined_properties = {}
            temperature_parameter = []
            for model_property in model_properties:
                single_property_values = material_model_dict[model_property]
                if len(single_property_values) > 1:
                    temperature_parameter_value = []
                    parameter_value = []
                    for property_value in single_property_values:
                        temperature_parameter_value.append(property_value["Temperature"])
                        parameter_value.append(property_value["value"])
                    temperature_parameter.append({"Temperature": temperature_parameter_value})
                    defined_properties[model_properties[model_property]] = {
                        "value": parameter_value,
                        "units": "",
                    }
                else:
                    defined_properties[model_properties[model_property]] = {
                        "value": [material_model_dict[model_property][0]["value"]],
                        "units": "",
                    }
            defined_models[model_name] = defined_properties
            if len(temperature_parameter) > 0:
                if len(temperature_parameter) > 1:
                    for i in range(len(temperature_parameter) - 1):
                        if not temperature_parameter[i] == temperature_parameter[i + 1]:
                            raise Exception("Multiple temperatures defined for same properties.")
                    temperature_parameter = [temperature_parameter[0]]
                defined_properties["independent_parameters"] = [
                    {
                        "name": "Temperature",
                        "values": {"value": temperature_parameter[0]["Temperature"], "units": ""},
                    }
                ]

            defined_models[model_name] = defined_properties

    # restrict to othotropic
    if "ElasticityOrthotropic" in defined_models.keys():
        defined_models.pop("ElasticityIsotropic", None)
    if "ThermalConductivityOrthotropic" in defined_models.keys():
        defined_models.pop("ThermalConductivityIsotropic")
    if "CoefficientofThermalExpansionOrthotropic::Instantaneus" in defined_models.keys():
        defined_models.pop("CoefficientofThermalExpansionIsotropic::Instantaneus", None)
    if "CoefficientofThermalExpansionOrthotropic::Secant" in defined_models.keys():
        defined_models.pop("CoefficientofThermalExpansionIsotropic::Secant", None)
    return defined_models


def read_mapdl(mapdl: _MapdlCore) -> dict[str, Material]:
    """
    Read materials from a provided MAPDL session.

    Returns them indexed by the material ID.

    Parameters
    ----------
    mapdl : _MapdlCore
        Active pyMAPDL session.

    Returns
    -------
    dict[str, Material]
        Materials currently active in the MAPDL session, indexed by their material ID.
    """
    raw_data = _parse_mp_list(mapdl)
    material_prop_dict = _parse_mp_temp_table(raw_data)
    materials = {}
    for material_name, material_properties in material_prop_dict.items():
        defined_models = _extract_defined_models_for_material(material_properties)
        material = Material(name=material_name)
        for class_name, payload in defined_models.items():
            model_class = MODEL_REGISTRY.get(class_name)
            if model_class:
                instance = model_class(**payload)
                material.append_models([instance])
        materials[material_name] = material
    return materials
